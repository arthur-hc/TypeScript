*** Encapsulamento
Em JS # é utilizado para encapsular propriedades

Para TS é utilizado o private

Caso deseje que ele possa ser visualizado, mas não alterado, utilize readonly

Quando não há nenhuma das modalidades é a atribuida a classe, assume-se o formato public que pode ser omitido

*** Getters
Definir um método getter

get Xablau() {
  return this.#Xablau
}

*** Modo Watch e compilando com mudanças
> No script a seguir: qualquer mudança, provoca uma re-compilação e starta o server novamente
(Nos scripts do package.json)
scripts: {
  ...,
  "server": "lite-server --baseDir=dist",
  "start": "concurrently \"npm run watch\" \"npm run server\"",
  "watch": "tsc -w"
}

*** Evitando compilações com erro e não aceitando any implicito
(Em tsconfig)
{
  "compilerOptions": {
    ...,
    "noEmitOnError": true,
    "noImplicitAny": true
  }
}

*** Generics
Array de negociações:
private negociations: Negociation[] = []

*** Evitando mutabilidade
Ao trazer o dado da instância diretamente, ele poderá ser modificado.
No caso do array, para permitir mudanças mas sem alterar a fonte, poderá ser usado uma cópia do original com spread
[...this.negociations]

Caso queira que seja o mesmo dado, utilizar o readonly Negociation[]

*** Retirando a necessidade de Getters
Tranforma a propriedades em public mas adiciona o readonly, assim, ele poderá ser retornado sem um getter, mas não permitindo edição

*** Programação defensiva
Em casos como Date, readonly não evita a edição devido ao setDate. Assim é necessário tornar a propriedade privada e retornar apenas a sua cópia

*** Protected
Caso queira que a propriedade seja acessivel por classes filhas, utilize protected no lugar de private. Assim, a classe filha poderá acessar a propriedade, mas não alterá-la. Também não poderá ser alterada por outra classe.

*** Utilizando tipo genéricos <T>
Dessa forma, podemos fazer a tipagem dinâmicamente. Exemplo:
O método update herdado por negociations-view de views.ts receberá como parâmetros negociations, já message-view receberá como parâmetros uma string.
Dessa forma, ao realizar o extends, devemos especificar o tipo utilizado na classe herdada antes definida com Generics <T>

*** Método abstrato
Método abstrato é um método que não possui implementação. Ele é herdado e implementado por outra classe filha. Caso não seja implementado, dará erro de compilação. No exemplo, template é um método abstrato que deve ser implementado pelas filhas de view.ts, de acordo com a sua necessidade de implementação.

*** Protected para filhas
Ao colocar na classe pai, e também nas filhas, o método poderá ser utilizado internamente, mas não acessado. Assim, após a instância, não poderá ser executado.
